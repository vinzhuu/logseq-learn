tags:: [[Cryptography]], [[Message Digest]]
alias:: [[数字签名]]
---

- ## 作用
	- 数字签名只能防止报文被篡改，并不能防止报文泄露 (即，报文可以被截获并解析)。
- ## 一段话解释
	- 发送方用一个哈希函数从报文文本中生成 **报文摘要** ，然后用 **发送方的私钥** 对这个摘要进行加密，这个加密后的摘要将作为报文的 **数字签名** ，和 报文 一起发送给接收方；
	- 接收方首先用与发送方一样的哈希函数从接收到的原始报文中计算出 **报文摘要** ，接着再用 **发送方的公钥** 对数字签名进行解密；
	- 如果这两个摘要相同，那么接收方就能确认该报文没有被篡改
		- 如果黑客要篡改报文，那么他必须使用 **发送方的私钥** 对篡改后的报文的数字摘要进行加密，再生成 **篡改后的证书** 发给接收方；
		- 然而，以目前计算机的算力，黑客根本无法反推私钥，也就无法加密 **篡改后的报文的数字摘要** 。
		- 如果黑客没有 **发送方私钥** ，则他需要做的事是：
			- 篡改原始报文
			  logseq.order-list-type:: number
			- 伪造一个 **加密后的报文摘要**
			  logseq.order-list-type:: number
				- 这个 **加密后的报文摘要** 需要达到的要求是:
					- Hash(篡改后的报文) = Pub-Decrypt(伪造的加密后的报文摘要, 发送方真实公钥)。
				- 显然，这个很难达到。
- ## 问题
	- ### 1、为什么需要哈希函数，而不是直接加密原始报文（即发送 原始报文 + 加密报文）
		- 效率问题：哈希函数的结果会得到比较小的报文，加密速度更快。
		  logseq.order-list-type:: number
		- 降低传输成本：哈希值显然比原始报文占用的空间更小。
		  logseq.order-list-type:: number
		- 兼容非对称加密的性质：非对称加密通常要求，需要加密的数据长度不能超过密钥的长度，否则需要分块加密。
		  logseq.order-list-type:: number
		- 增强安全性：使用的哈希函数可以做到，原始数据细微的改动，即造成其哈希值的大改。
		  logseq.order-list-type:: number
	- ### 2、为什么不使用接收方的公钥进行加密？
		- 使用接收方的公钥进行加密，则黑客可以篡改原始报文，并伪造最后生成的证书，因为公钥谁都能获取。
		- ==使用他接收方的公钥加密，仅能保证数据不被第三方解析。==
		- ==而使用我发送方的私钥加密，仅能保证数据不被篡改。==
	-